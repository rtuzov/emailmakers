import { EmailTemplateGenerationService, ContentGenerationPipeline } from '../../src/domains/email-marketing/services/email-template-generation-service';
import { ContentBrief } from '../../src/domains/email-marketing/entities/content-brief';
import { EmailTemplate } from '../../src/domains/email-marketing/entities/email-template';
import { LLMOrchestratorService } from '../../src/domains/content-generation/services/llm-orchestrator-service';
import { FigmaService } from '../../src/domains/design-system/services/figma-service';
import { MJMLProcessorService } from '../../src/domains/template-processing/services/mjml-processor-service';
import { QualityAssuranceService } from '../../src/domains/quality-assurance/services/quality-assurance-service';
import { CacheService } from '../../src/shared/infrastructure/cache/cache-service';
import { MetricsService } from '../../src/shared/infrastructure/monitoring/metrics-service';
import { EventBusService } from '../../src/shared/infrastructure/event-bus/event-bus-service';

// Mock all dependencies
jest.mock('../../src/domains/content-generation/services/llm-orchestrator-service');
jest.mock('../../src/domains/design-system/services/figma-service');
jest.mock('../../src/domains/template-processing/services/mjml-processor-service');
jest.mock('../../src/domains/quality-assurance/services/quality-assurance-service');
jest.mock('../../src/shared/infrastructure/cache/cache-service');
jest.mock('../../src/shared/infrastructure/monitoring/metrics-service');
jest.mock('../../src/shared/infrastructure/event-bus/event-bus-service');

describe('EmailTemplateGenerationService', () => {
  let service: EmailTemplateGenerationService;
  let contentPipeline: jest.Mocked<ContentGenerationPipeline>;
  let figmaService: jest.Mocked<FigmaService>;
  let templateProcessor: jest.Mocked<MJMLProcessorService>;
  let qaService: jest.Mocked<QualityAssuranceService>;
  let cacheService: jest.Mocked<CacheService>;
  let metricsService: jest.Mocked<MetricsService>;
  let eventBus: jest.Mocked<EventBusService>;

  beforeEach(() => {
    // Create mocked instances
    contentPipeline = {
      processContentBrief: jest.fn().mockResolvedValue({
        id: 'content-123',
        contentType: 'body',
        content: 'Generated email content about our exciting new product launch',
        metadata: {
          wordCount: 10,
          tone: 'professional',
          provider: 'openai',
          generatedAt: new Date(),
          version: 1
        },
        alternatives: ['Subject Line', 'Call to Action', 'Preview text'],
        quality: {
          score: 0.8,
          readabilityScore: 0.8,
          brandAlignment: 0.8,
          engagement: 0.8
        }
      }),
    } as any;

    figmaService = {
      extractDesignSystem: jest.fn(),
    } as any;

    templateProcessor = {
      processTemplate: jest.fn(),
    } as any;

    qaService = {
      runQualityAssurance: jest.fn(),
    } as any;

    cacheService = {
      get: jest.fn(),
      set: jest.fn(),
    } as any;

    metricsService = {
      incrementCounter: jest.fn(),
      recordTemplateGeneration: jest.fn(),
    } as any;

    eventBus = {
      emit: jest.fn(),
    } as any;

    // Create service instance
    service = new EmailTemplateGenerationService(
      contentPipeline,
      figmaService,
      templateProcessor,
      qaService,
      cacheService,
      metricsService,
      eventBus
    );
  });

  describe('generateEmailTemplate', () => {
    it('should successfully generate an email template with text brief', async () => {
      // Arrange
      const brief = ContentBrief.fromText(
        'Create a newsletter about our new product launch',
        'Product Launch Newsletter',
        'Announcing our exciting new product'
      );

      const mockContent = {
        type: 'text',
        subject: 'Exciting Product Launch!',
        body: 'We are thrilled to announce our new product...',
        cta: 'Learn More',
        preheader: 'Discover our latest innovation',
        metadata: { provider: 'openai', generatedAt: new Date() }
      };

      // Create an actual EmailTemplate instance
      const mockTemplate = EmailTemplate.create(
        '<div style="margin: 0;">Test HTML</div>',
        '<div>Test HTML</div>',
        {
          subject: 'Generated Email',
          preheader: 'Generated with AI',
          body: 'Generated email content',
          cta: ['Learn More'],
          footer: 'Email generated by Email-Makers AI',
          unsubscribeLink: '#unsubscribe'
        },
        {
          templateType: 'newsletter',
          name: 'Test Template',
          tags: [],
          optimizations: {
            cssInlined: true,
            imagesOptimized: false,
            darkModeSupported: false,
            mobileOptimized: true,
            accessibilityEnhanced: true,
            performanceOptimized: true,
            compressionApplied: false,
            minified: false
          },
          rawCSS: '',
          inlineCSS: '<div style="margin: 0;">Test HTML</div>'
        }
      );

      const mockQualityReport = {
        id: 'test-quality-report-1',
        templateId: 'template_test_123',
        overallScore: 0.75,
        timestamp: new Date(),
        validation: {
          isValid: true,
          score: 0.8,
          issues: []
        },
        accessibility: {
          score: 0.8,
          issues: [],
          wcagLevel: 'AA' as const
        },
        performance: {
          fileSize: 800,
          loadTime: 120,
          imageOptimization: 0.7,
          cssOptimization: 1
        },
        compatibility: {
          clients: [],
          overallCompatibility: 0.9
        },
        recommendations: [
          'Consider optimizing images for better performance',
          'Add more descriptive alt text'
        ]
      };

      // Setup mocks
      cacheService.get.mockResolvedValue(null);
      contentPipeline.processContentBrief.mockResolvedValue(mockContent as any);
      
      const mockOptimizedTemplate = {
        html: mockTemplate.html,
        css: 'body { margin: 0; }',
        inlinedHtml: mockTemplate.html,
        darkModeHtml: mockTemplate.html,
        fileSize: 1000,
        performance: {
          fileSize: 1000,
          cssSize: 50,
          imageCount: 0,
          totalImageSize: 0,
          loadTime: 100,
          compressionRatio: 0.8
        },
        compatibility: {
          overall: 0.9,
          clientScores: {
            gmail: 0.9,
            outlook: 0.85,
            'outlook-web': 0.85,
            'apple-mail': 0.95,
            'yahoo-mail': 0.8,
            thunderbird: 0.85,
            'samsung-mail': 0.8,
            'android-mail': 0.8,
            'ios-mail': 0.95
          },
          issues: [],
          recommendations: []
        },
        optimizations: {
          applied: [],
          skipped: [],
          performance: {
            originalSize: 1200,
            optimizedSize: 1000,
            compressionRatio: 0.8
          }
        }
      };
      templateProcessor.processTemplate.mockResolvedValue(mockOptimizedTemplate);
      qaService.runQualityAssurance.mockResolvedValue(mockQualityReport as any);
      eventBus.emit.mockResolvedValue(undefined);

      // Act
      const result = await service.generateEmailTemplate(brief);

      // Assert
      expect(result).toBeDefined();
      expect(result.template).toEqual(expect.objectContaining({
        html: expect.any(String),
        mjml: expect.any(String),
        content: expect.objectContaining({
          subject: expect.any(String),
          body: expect.any(String)
        }),
        metadata: expect.objectContaining({
          templateType: 'newsletter',
          version: expect.any(String)
        })
      }));
      expect(result.qualityReport).toBe(mockQualityReport);
      expect(result.metadata.contentProvider).toBe('openai');
      expect(result.metadata.designSystemUsed).toBe(false);
      expect(result.metadata.qualityScore).toBe(0.75);

      // Verify service calls
      expect(contentPipeline.processContentBrief).toHaveBeenCalledWith(brief, expect.any(Object));
      expect(templateProcessor.processTemplate).toHaveBeenCalledWith(
        mockContent, 
        null, 
        expect.objectContaining({
          darkModeSupport: true,
          optimizeForMobile: true,
          inlineCSS: true,
          minifyHTML: true
        })
      );
      expect(qaService.runQualityAssurance).toHaveBeenCalledWith(expect.any(String));

      // Verify events
      expect(eventBus.emit).toHaveBeenCalledWith('template.generation.started', expect.any(Object));
      expect(eventBus.emit).toHaveBeenCalledWith('template.generation.completed', expect.any(Object));

      // Verify metrics
      expect(metricsService.incrementCounter).toHaveBeenCalledWith('template.generation.started', expect.any(Object));
      expect(metricsService.recordTemplateGeneration).toHaveBeenCalledWith(expect.any(Number), true, 'openai');
    });

    it('should successfully generate an email template with Figma URL', async () => {
      // Arrange - Use a valid Figma URL format
      const brief = ContentBrief.fromFigmaURL(
        'https://www.figma.com/file/1234567890123456789012/Test-Design',
        'Figma-based Newsletter',
        'Newsletter using Figma design system'
      );

      const mockContent = {
        type: 'figma_url',
        subject: 'Design System Newsletter',
        body: 'Beautiful newsletter with consistent design...',
        cta: 'View Design',
        preheader: 'Consistent brand experience',
        metadata: { provider: 'openai', generatedAt: new Date() }
      };

      const mockDesignSystem = {
        tokens: {
          colors: [{ name: 'primary', value: '#007bff' }],
          typography: [{ name: 'heading', fontFamily: 'Arial' }]
        },
        components: [],
        assets: []
      };

      // Create an actual EmailTemplate instance for Figma test
      const mockTemplate = EmailTemplate.create(
        '<div style="margin: 0;">Design System HTML</div>',
        '<div>Design System HTML</div>',
        {
          subject: 'Design System Newsletter',
          preheader: 'Consistent brand experience',
          body: 'Beautiful newsletter with consistent design...',
          cta: ['View Design'],
          footer: 'Email generated by Email-Makers AI',
          unsubscribeLink: '#unsubscribe'
        },
        {
          templateType: 'newsletter',
          name: 'Design System Template',
          tags: [],
          optimizations: {
            cssInlined: true,
            imagesOptimized: true,
            darkModeSupported: false,
            mobileOptimized: true,
            accessibilityEnhanced: true,
            performanceOptimized: true,
            compressionApplied: true,
            minified: false
          },
          rawCSS: 'body { margin: 0; }',
          inlineCSS: '<div style="margin: 0;">Design System HTML</div>'
        }
      );

      const mockQualityReport = {
        id: 'test-quality-report-2',
        templateId: 'template_test_456',
        overallScore: 0.92,
        timestamp: new Date(),
        validation: {
          isValid: true,
          score: 0.95,
          issues: []
        },
        accessibility: {
          score: 0.9,
          issues: [],
          wcagLevel: 'AA' as const
        },
        performance: {
          fileSize: 1200,
          loadTime: 90,
          imageOptimization: 0.95,
          cssOptimization: 1
        },
        compatibility: {
          clients: [],
          overallCompatibility: 0.95
        },
        recommendations: ['Great email template with minimal optimizations needed']
      };

      // Setup mocks
      cacheService.get.mockResolvedValue(null);
      contentPipeline.processContentBrief.mockResolvedValue(mockContent as any);
      figmaService.extractDesignSystem.mockResolvedValue(mockDesignSystem as any);
      
      const mockOptimizedTemplate = {
        html: mockTemplate.html,
        css: 'body { margin: 0; }',
        inlinedHtml: mockTemplate.html,
        darkModeHtml: mockTemplate.html,
        fileSize: 1200,
        performance: {
          fileSize: 1200,
          cssSize: 60,
          imageCount: 0,
          totalImageSize: 0,
          loadTime: 90,
          compressionRatio: 0.85
        },
        compatibility: {
          overall: 0.95,
          clientScores: {
            gmail: 0.95,
            outlook: 0.9,
            'outlook-web': 0.9,
            'apple-mail': 0.98,
            'yahoo-mail': 0.85,
            thunderbird: 0.9,
            'samsung-mail': 0.85,
            'android-mail': 0.85,
            'ios-mail': 0.98
          },
          issues: [],
          recommendations: []
        },
        optimizations: {
          applied: [],
          skipped: [],
          performance: {
            originalSize: 1400,
            optimizedSize: 1200,
            compressionRatio: 0.85
          }
        }
      };
      templateProcessor.processTemplate.mockResolvedValue(mockOptimizedTemplate);
      qaService.runQualityAssurance.mockResolvedValue(mockQualityReport as any);
      eventBus.emit.mockResolvedValue(undefined);

      // Act
      const result = await service.generateEmailTemplate(brief, {
        figmaUrl: 'https://www.figma.com/file/1234567890123456789012/Test-Design'
      });

      // Assert
      expect(result).toBeDefined();
      expect(result.template).toEqual(expect.objectContaining({
        html: expect.any(String),
        mjml: expect.any(String),
        content: expect.objectContaining({
          subject: expect.any(String),
          body: expect.any(String)
        }),
        metadata: expect.objectContaining({
          templateType: 'newsletter',
          version: expect.any(String)
        })
      }));
      expect(result.metadata.designSystemUsed).toBe(true);
      expect(result.metadata.qualityScore).toBe(0.92);

      // Verify Figma service was called
      expect(figmaService.extractDesignSystem).toHaveBeenCalledWith(
        'https://www.figma.com/file/1234567890123456789012/Test-Design'
      );

      // Verify template processor received design system
      expect(templateProcessor.processTemplate).toHaveBeenCalledWith(
        expect.objectContaining({
          id: expect.any(String),
          name: 'Generated Template',
          mjmlContent: expect.any(String),
          designTokens: expect.objectContaining({
            colors: expect.arrayContaining([
              expect.objectContaining({
                name: 'primary',
                value: '#007bff'
              })
            ]),
            typography: expect.arrayContaining([
              expect.objectContaining({
                name: 'heading',
                fontFamily: 'Arial'
              })
            ])
          }),
          targetClients: expect.arrayContaining(['gmail', 'outlook', 'apple-mail']),
          requirements: expect.objectContaining({
            maxFileSize: 100,
            darkModeSupport: true,
            responsiveDesign: true,
            accessibilityLevel: 'AA'
          })
        }),
        expect.objectContaining({
          priority: 'compatibility',
          aggressiveness: 'moderate',
          preserveFormatting: true
        })
      );
    });

    it('should use cache when available', async () => {
      // Arrange
      const brief = ContentBrief.fromText('Test brief for caching');
      
      const cachedResult = {
        jobId: 'cached-job-123',
        template: EmailTemplate.create('<mj-text>Cached</mj-text>', '<div>Cached</div>', {
          subject: 'Cached Subject',
          body: 'Cached Body',
          cta: ['Cached CTA'],
          preheader: 'Cached Preheader'
        }),
        qualityReport: { overallScore: 0.9 },
        metadata: {
          duration: 1000,
          generatedAt: new Date(),
          version: '1.0',
          contentProvider: 'openai',
          designSystemUsed: false,
          qualityScore: 0.9
        }
      };

      // Setup cache to return cached result
      cacheService.get.mockResolvedValue(cachedResult);

      // Act
      const result = await service.generateEmailTemplate(brief);

      // Assert
      expect(result).toBe(cachedResult);
      expect(cacheService.get).toHaveBeenCalled();
      
      // Verify no other services were called
      expect(contentPipeline.processContentBrief).not.toHaveBeenCalled();
      expect(templateProcessor.processTemplate).not.toHaveBeenCalled();
      expect(qaService.runQualityAssurance).not.toHaveBeenCalled();

      // Verify cache hit event
      expect(eventBus.emit).toHaveBeenCalledWith('template.generation.cache_hit', expect.any(Object));
      expect(metricsService.incrementCounter).toHaveBeenCalledWith('template.generation.cache_hit');
    });

    it('should handle errors gracefully', async () => {
      // Arrange
      const brief = ContentBrief.fromText('Test brief that will fail');
      const errorMessage = 'Content generation failed';

      // Setup mocks to simulate failure
      cacheService.get.mockResolvedValue(null);
      contentPipeline.processContentBrief.mockRejectedValue(new Error(errorMessage));
      eventBus.emit.mockResolvedValue(undefined);

      // Act & Assert
      await expect(service.generateEmailTemplate(brief)).rejects.toThrow('Template generation failed');

      // Verify error events and metrics
      expect(eventBus.emit).toHaveBeenCalledWith('template.generation.started', expect.any(Object));
      expect(eventBus.emit).toHaveBeenCalledWith('template.generation.failed', expect.objectContaining({
        error: expect.stringContaining(errorMessage)
      }));
      expect(metricsService.recordTemplateGeneration).toHaveBeenCalledWith(expect.any(Number), false, 'unknown');
    });

    it('should skip cache when requested', async () => {
      // Arrange
      const brief = ContentBrief.fromText('Test brief with cache skip');
      
      const mockContent = {
        type: 'text',
        subject: 'No Cache Subject',
        body: 'No cache body...',
        cta: 'No Cache CTA',
        preheader: 'No cache preheader',
        metadata: { provider: 'anthropic', generatedAt: new Date() }
      };

      const mockTemplate = {
        html: '<div>No Cache</div>',
        css: 'body { margin: 0; }',
        inlinedHtml: '<div style="margin: 0;">No Cache</div>',
        darkModeHtml: '<div style="margin: 0;">No Cache</div>',
        fileSize: 800,
        performance: {
          fileSize: 800,
          cssSize: 40,
          imageCount: 0,
          totalImageSize: 0,
          loadTime: 80,
          compressionRatio: 0.75
        },
        compatibility: {
          overall: 0.85,
          clientScores: {
            gmail: 0.9,
            outlook: 0.8,
            'outlook-web': 0.85,
            'apple-mail': 0.9,
            'yahoo-mail': 0.75,
            thunderbird: 0.8,
            'samsung-mail': 0.75,
            'android-mail': 0.75,
            'ios-mail': 0.9
          },
          issues: [],
          recommendations: []
        },
        optimizations: {
          applied: [],
          skipped: [],
          performance: {
            originalSize: 1000,
            optimizedSize: 800,
            compressionRatio: 0.75
          }
        }
      };

      const mockQualityReport = {
        id: 'test-quality-report-1',
        templateId: 'template_test_123',
        overallScore: 0.75,
        timestamp: new Date(),
        validation: {
          isValid: true,
          score: 0.8,
          issues: []
        },
        accessibility: {
          score: 0.8,
          issues: [],
          wcagLevel: 'AA' as const
        },
        performance: {
          fileSize: 800,
          loadTime: 120,
          imageOptimization: 0.7,
          cssOptimization: 1
        },
        compatibility: {
          clients: [],
          overallCompatibility: 0.9
        },
        recommendations: [
          'Consider optimizing images for better performance',
          'Add more descriptive alt text'
        ]
      };

      // Setup mocks
      contentPipeline.processContentBrief.mockResolvedValue(mockContent as any);
      templateProcessor.processTemplate.mockResolvedValue(mockTemplate);
      qaService.runQualityAssurance.mockResolvedValue(mockQualityReport as any);
      eventBus.emit.mockResolvedValue(undefined);

      // Act
      const result = await service.generateEmailTemplate(brief, { skipCache: true });

      // Assert
      expect(result).toBeDefined();
      expect(result.metadata.contentProvider).toBe('anthropic');
      
      // Verify cache was not checked
      expect(cacheService.get).not.toHaveBeenCalled();
      
      // Verify all services were called
      expect(contentPipeline.processContentBrief).toHaveBeenCalled();
      expect(templateProcessor.processTemplate).toHaveBeenCalled();
      expect(qaService.runQualityAssurance).toHaveBeenCalled();
    });
  });
});

describe('ContentGenerationPipeline', () => {
  let pipeline: ContentGenerationPipeline;
  let llmOrchestrator: jest.Mocked<LLMOrchestratorService>;
  let cacheService: jest.Mocked<CacheService>;
  let metricsService: jest.Mocked<MetricsService>;

  beforeEach(() => {
    llmOrchestrator = {
      generateContent: jest.fn(),
    } as any;

    cacheService = {
      get: jest.fn(),
      set: jest.fn(),
    } as any;

    metricsService = {
      incrementCounter: jest.fn(),
      recordDuration: jest.fn(),
    } as any;

    pipeline = new ContentGenerationPipeline(
      llmOrchestrator,
      cacheService,
      metricsService
    );
  });

  describe('processContentBrief', () => {
    it('should process a content brief successfully', async () => {
      // Arrange
      const brief = ContentBrief.fromText(
        'Create a promotional email for summer sale',
        'Summer Sale Promo',
        'Get customers excited about summer discounts'
      );

      // Mock LLM responses for different content types
      llmOrchestrator.generateContent
        .mockResolvedValueOnce({
          subjectLine: 'Summer Sale - 50% Off Everything!',
          preheader: 'Limited time summer savings',
          bodyContent: { sections: [], cta: { primary: { text: '' } } },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 150, generationTime: 1500, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: '',
          bodyContent: { 
            sections: [{ type: 'hero', content: 'Don\'t miss our biggest summer sale...', confidence: 0.9 }],
            cta: { primary: { text: 'Shop Now', confidence: 0.9 } }
          },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 150, generationTime: 1500, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: '',
          bodyContent: { 
            sections: [],
            cta: { primary: { text: 'Shop Now', confidence: 0.9 } }
          },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 150, generationTime: 1500, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: 'Limited time summer savings',
          bodyContent: { sections: [], cta: { primary: { text: '' } } },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 150, generationTime: 1500, retryCount: 0, qualityChecks: [] }
        } as any);

      // Act
      const result = await pipeline.processContentBrief(brief, {
        campaignType: 'promotional',
        priorityProvider: 'openai'
      });

      // Assert
      expect(result).toBeDefined();
      expect(result.content).toBeDefined();
      expect(result.content).toContain('Don\'t miss our biggest summer sale...');
      expect(result.metadata).toBeDefined();
      expect(result.metadata.provider).toBe('openai');
      expect(result.metadata.wordCount).toBeGreaterThan(0);

      // Verify LLM orchestrator was called 4 times (subject, body, cta, preheader)
      expect(llmOrchestrator.generateContent).toHaveBeenCalledTimes(4);
    });

    it('should handle different campaign types', async () => {
      // Arrange
      const brief = ContentBrief.fromText('Welcome new subscribers');
      
      // Mock LLM responses for different content types
      llmOrchestrator.generateContent
        .mockResolvedValueOnce({
          subjectLine: 'Welcome to Our Community!',
          preheader: '',
          bodyContent: { sections: [], cta: { primary: { text: '' } } },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 120, generationTime: 1200, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: '',
          bodyContent: { 
            sections: [{ type: 'hero', content: 'Thank you for joining us...', confidence: 0.9 }],
            cta: { primary: { text: 'Get Started', confidence: 0.9 } }
          },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 120, generationTime: 1200, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: '',
          bodyContent: { 
            sections: [],
            cta: { primary: { text: 'Get Started', confidence: 0.9 } }
          },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 120, generationTime: 1200, retryCount: 0, qualityChecks: [] }
        } as any)
        .mockResolvedValueOnce({
          subjectLine: '',
          preheader: 'Your journey begins here',
          bodyContent: { sections: [], cta: { primary: { text: '' } } },
          qualityScore: 0.9,
          metadata: { provider: 'openai', model: 'gpt-4', tokensUsed: 120, generationTime: 1200, retryCount: 0, qualityChecks: [] }
        } as any);

      // Act
      const result = await pipeline.processContentBrief(brief, {
        campaignType: 'welcome'
      });

      // Assert
      expect(result.content).toBeDefined();
      expect(result.content).toContain('Thank you for joining us...');
      expect(result.metadata.wordCount).toBeGreaterThan(0);
      expect(llmOrchestrator.generateContent).toHaveBeenCalledTimes(4);
    });
  });
}); 