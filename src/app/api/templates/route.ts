import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/shared/infrastructure/database/connection';
import { email_templates, users } from '@/shared/infrastructure/database/schema';
import { eq, like, and, desc, asc, count, or, ilike, sql, gte, lte, between } from 'drizzle-orm';

/**
 * GET /api/templates
 * Retrieve email templates with filtering, searching, and pagination
 */

interface Template {
  id: string;
  name: string;
  category: string;
  description: string;
  thumbnail?: string;
  preview?: string;
  createdAt: string;
  updatedAt?: string;
  tags?: string[];
  status?: 'published' | 'draft';
  openRate?: number;
  clickRate?: number;
  htmlContent?: string;
  mjmlContent?: string;
  textContent?: string;
  subjectLine?: string;
  previewText?: string;
  qualityScore?: number;
  agentGenerated?: boolean;
  userId?: string;
  // Database-specific fields
  briefText?: string;
  generatedContent?: any;
  mjmlCode?: string;
  htmlOutput?: string;
  designTokens?: any;
}

interface TemplatesResponse {
  success: boolean;
  data: {
    templates: Template[];
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
    filters: {
      categories: Array<{ value: string; label: string; count: number }>;
      tags: string[];
    };
  };
  metadata?: {
    query_time: number;
    cache_status: string;
  };
}

// No mock templates - all templates must be generated by agents or retrieved from database

// Force dynamic behavior for API route with query parameters
export const dynamic = 'force-dynamic'

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = Math.min(parseInt(searchParams.get('limit') || '12'), 50); // Max 50 per page
    const category = searchParams.get('category');
    const search = searchParams.get('search');
    const status = searchParams.get('status') as 'published' | 'draft' | null;
    const sortBy = searchParams.get('sortBy') || 'createdAt';
    const sortOrder = searchParams.get('sortOrder') || 'desc';
    const tags = searchParams.get('tags')?.split(',').filter(Boolean);
    const userId = searchParams.get('userId');
    
    // Advanced filtering parameters
    const qualityMin = searchParams.get('qualityMin');
    const qualityMax = searchParams.get('qualityMax');
    const agentGenerated = searchParams.get('agentGenerated');
    const dateStart = searchParams.get('dateStart');
    const dateEnd = searchParams.get('dateEnd');

    // Validate parameters
    if (page < 1 || limit < 1) {
      return NextResponse.json({
        success: false,
        error: 'Invalid pagination parameters',
        message: 'Page and limit must be positive integers'
      }, { status: 400 });
    }

    const validSortFields = ['createdAt', 'updatedAt', 'name', 'openRate', 'clickRate', 'qualityScore'];
    if (!validSortFields.includes(sortBy)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid sort field',
        message: `Sort field must be one of: ${validSortFields.join(', ')}`
      }, { status: 400 });
    }

    // Validate quality score range
    if (qualityMin && (isNaN(Number(qualityMin)) || Number(qualityMin) < 0 || Number(qualityMin) > 100)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid quality score minimum value'
      }, { status: 400 });
    }

    if (qualityMax && (isNaN(Number(qualityMax)) || Number(qualityMax) < 0 || Number(qualityMax) > 100)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid quality score maximum value'
      }, { status: 400 });
    }

    // Validate status enum
    if (status && !['published', 'draft'].includes(status)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid status value'
      }, { status: 400 });
    }

    // Validate boolean parameters
    if (agentGenerated && !['true', 'false'].includes(agentGenerated)) {
      return NextResponse.json({
        success: false,
        error: 'Invalid boolean value for agentGenerated'
      }, { status: 400 });
    }

    // Validate date format
    if (dateStart && isNaN(Date.parse(dateStart))) {
      return NextResponse.json({
        success: false,
        error: 'Invalid date format for dateStart'
      }, { status: 400 });
    }

    if (dateEnd && isNaN(Date.parse(dateEnd))) {
      return NextResponse.json({
        success: false,
        error: 'Invalid date format for dateEnd'
      }, { status: 400 });
    }

    // Build database query conditions
    const conditions = [];

    // Apply filters
    if (category && category !== 'all') {
      // Note: Using mock data approach since database schema doesn't have category field
      // In real scenario, would need to add category field to email_templates table
      conditions.push(sql`1=0`); // Temporary placeholder - no real category filtering yet
    }

    if (status) {
      conditions.push(eq(email_templates.status, status));
    }

    if (search) {
      const searchPattern = `%${search}%`;
      conditions.push(
        or(
          ilike(email_templates.name, searchPattern),
          ilike(email_templates.description, searchPattern),
          ilike(email_templates.brief_text, searchPattern)
        )
      );
    }

    if (userId) {
      conditions.push(eq(email_templates.user_id, userId));
    }

    // Quality score filtering
    if (qualityMin) {
      conditions.push(gte(email_templates.quality_score, Number(qualityMin)));
    }

    if (qualityMax) {
      conditions.push(lte(email_templates.quality_score, Number(qualityMax)));
    }

    // Agent generation filtering
    if (agentGenerated !== null && agentGenerated !== undefined) {
      // For now, we'll assume all database templates are agent-generated
      // In a real scenario, you'd add an agent_generated column to the schema
      if (agentGenerated === 'false') {
        // If looking for non-AI templates, return no results from DB (fallback to mock)
        conditions.push(sql`1=0`);
      }
    }

    // Date range filtering
    if (dateStart) {
      conditions.push(gte(email_templates.created_at, new Date(dateStart)));
    }

    if (dateEnd) {
      conditions.push(lte(email_templates.created_at, new Date(dateEnd)));
    }

    // Tag filtering (simplified for mock - in real scenario would need proper tags table)
    if (tags && tags.length > 0) {
      // Since we don't have a tags table yet, fall back to mock filtering
      conditions.push(sql`1=0`);
    }

    // Build WHERE clause
    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Build ORDER BY clause
    let orderByClause;
    const sortColumn = (() => {
      switch (sortBy) {
        case 'createdAt': return email_templates.created_at;
        case 'updatedAt': return email_templates.updated_at;
        case 'name': return email_templates.name;
        case 'qualityScore': return email_templates.quality_score;
        default: return email_templates.created_at;
      }
    })();

    orderByClause = sortOrder === 'desc' ? desc(sortColumn) : asc(sortColumn);

    // Get total count for pagination
    const totalResult = await db
      .select({ count: count() })
      .from(email_templates)
      .where(whereClause);
    
    const total = totalResult[0]?.count || 0;
    const totalPages = Math.ceil(total / limit);
    const offset = (page - 1) * limit;

    // Query templates with pagination
    const dbTemplates = await db
      .select({
        id: email_templates.id,
        user_id: email_templates.user_id,
        name: email_templates.name,
        description: email_templates.description,
        brief_text: email_templates.brief_text,
        generated_content: email_templates.generated_content,
        mjml_code: email_templates.mjml_code,
        html_output: email_templates.html_output,
        design_tokens: email_templates.design_tokens,
        status: email_templates.status,
        quality_score: email_templates.quality_score,
        created_at: email_templates.created_at,
        updated_at: email_templates.updated_at,
      })
      .from(email_templates)
      .where(whereClause)
      .orderBy(orderByClause)
      .limit(limit)
      .offset(offset);

    // Transform database results to Template interface
    const paginatedTemplates: Template[] = dbTemplates.map(dbTemplate => ({
      id: dbTemplate.id,
      name: dbTemplate.name,
      category: 'general', // Default category since not in schema yet
      description: dbTemplate.description || '',
      thumbnail: '/api/placeholder/400/300',
      createdAt: dbTemplate.created_at.toISOString(),
      updatedAt: dbTemplate.updated_at?.toISOString(),
      status: (dbTemplate.status as 'published' | 'draft') || 'draft',
      qualityScore: dbTemplate.quality_score || undefined,
      agentGenerated: true, // Default for now
      userId: dbTemplate.user_id,
      // Include database-specific fields
      briefText: dbTemplate.brief_text,
      generatedContent: dbTemplate.generated_content,
      mjmlCode: dbTemplate.mjml_code,
      htmlOutput: dbTemplate.html_output,
      designTokens: dbTemplate.design_tokens,
      // Mock additional fields for now
      openRate: Math.random() * 100,
      clickRate: Math.random() * 50,
      tags: ['database', 'generated'],
    }));

    // No fallback to mock data - return empty results if database has no templates
    let finalTemplates = paginatedTemplates;
    let finalTotal = total;
    let isUsingFallback = false;

    // Generate filter options (database only)
    const categories = [
      { value: 'general', label: 'General', count: finalTotal }
    ];

    const allTags = ['database', 'generated'];

    const queryTime = Date.now() - startTime;

    const finalTotalPages = Math.ceil(finalTotal / limit);

    const response: TemplatesResponse = {
      success: true,
      data: {
        templates: finalTemplates,
        pagination: {
          total: finalTotal,
          page,
          limit,
          totalPages: finalTotalPages,
          hasNext: page < finalTotalPages,
          hasPrev: page > 1
        },
        filters: {
          categories: [
            { value: 'all', label: 'All Templates', count: finalTotal },
            ...categories
          ],
          tags: allTags
        }
      },
      metadata: {
        query_time: queryTime,
        cache_status: isUsingFallback ? 'fallback' : 'database'
      }
    };

    return NextResponse.json(response, {
      headers: {
        'Cache-Control': 'public, max-age=60, stale-while-revalidate=300',
        'X-Total-Count': finalTotal.toString(),
        'X-Page': page.toString(),
        'X-Per-Page': limit.toString(),
        'X-Data-Source': isUsingFallback ? 'fallback' : 'database'
      }
    });

  } catch (error) {
    console.error('❌ Templates API error:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Failed to fetch templates',
      message: error instanceof Error ? error.message : 'Unknown error',
      code: 'TEMPLATES_FETCH_ERROR',
      timestamp: new Date().toISOString(),
      details: process.env.NODE_ENV === 'development' ? {
        stack: error instanceof Error ? error.stack : null,
        type: error instanceof Error ? error.constructor.name : 'Unknown'
      } : undefined
    }, { status: 500 });
  }
} 