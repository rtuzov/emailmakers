import { NextRequest, NextResponse } from 'next/server';

/**
 * Comprehensive Agent Workflow Test
 * Tests complete T1-T9 workflow including new tools (diff, patch, upload)
 */
export async function POST(request: NextRequest) {
  try {
    console.log('üß™ Running comprehensive agent workflow test...');

    // Safely parse request body
    let body: { topic?: string } = {};
    try {
      const requestText = await request.text();
      if (requestText.trim()) {
        body = JSON.parse(requestText);
      }
    } catch (parseError) {
      console.log('üì≠ No request body provided, using defaults');
    }
    
    const { topic = '–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ –≤ –ú–æ—Å–∫–≤—É' } = body;

    // Import all tools
    const { getPrices } = await import('@/agent/tools/prices');
    const { getFigmaAssets } = await import('@/agent/tools/figma');
    const { generateCopy } = await import('@/agent/tools/copy');
    const { renderMjml } = await import('@/agent/tools/mjml');
    const { diffHtml } = await import('@/agent/tools/diff');
    const { patchHtml } = await import('@/agent/tools/patch');
    const { uploadToS3 } = await import('@/agent/tools/upload');

    console.log('üîß Testing complete T1-T9 workflow...');

    // T2: Get flight prices
    console.log('üìä T2: Getting flight prices...');
    const pricesResult = await getPrices({
      origin: 'LED',
      destination: 'MOW'
      // date_range will be auto-generated by the function
    });

    if (!pricesResult.success) {
      throw new Error(`T2 failed: ${pricesResult.error}`);
    }

    // T1: Get Figma assets
    console.log('üé® T1: Getting Figma assets...');
    const assetsResult = await getFigmaAssets({
      tags: ['–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ', '–ú–æ—Å–∫–≤–∞', '–∞–∫—Ü–∏—è', '–ø–æ–ª–µ—Ç']
    });

    if (!assetsResult.success) {
      throw new Error(`T1 failed: ${assetsResult.error}`);
    }

    // T3: Generate copy
    console.log('‚úçÔ∏è T3: Generating copy...');
    const copyResult = await generateCopy({
      topic,
      prices: pricesResult.data
    });

    if (!copyResult.success) {
      throw new Error(`T3 failed: ${copyResult.error}`);
    }

    // T4: Render MJML
    console.log('üé® T4: Rendering MJML...');
    const mjmlResult = await renderMjml({
      content: copyResult.data,
      assets: assetsResult.data
    });

    if (!mjmlResult.success) {
      throw new Error(`T4 failed: ${mjmlResult.error}`);
    }

    // T5: Test HTML diff (compare with baseline)
    console.log('üîç T5: Testing HTML diff...');
    const baselineHtml = generateBaselineTemplate();
    const diffResult = await diffHtml({
      original_html: baselineHtml,
      modified_html: mjmlResult.data.html,
      tolerance: 0.05 // 5% tolerance
    });

    if (!diffResult.success) {
      throw new Error(`T5 failed: ${diffResult.error}`);
    }

    // T6: Patch HTML if needed
    console.log('üîß T6: Patching HTML...');
    let finalHtml = mjmlResult.data.html;
    
    if (diffResult.data.layout_regression) {
      console.log('üö® Layout regression detected, applying patches...');
      const patchResult = await patchHtml({
        html: mjmlResult.data.html,
        issues: diffResult.data.significant_changes,
        patch_type: 'email_optimization'
      });

      if (patchResult.success) {
        finalHtml = patchResult.data.patched_html;
        console.log('‚úÖ HTML patches applied successfully');
      } else {
        console.warn('‚ö†Ô∏è HTML patching failed, using original HTML');
      }
    } else {
      console.log('‚úÖ No layout regression detected, HTML is good');
    }

    // T9: Upload to S3
    console.log('‚òÅÔ∏è T9: Uploading to S3...');
    const uploadResult = await uploadToS3({
      html: finalHtml,
      mjml_source: mjmlResult.data.mjml_source,
      assets: {
        images: assetsResult.data.paths || [],
        metadata: assetsResult.data.metadata || {}
      }
    });

    if (!uploadResult.success) {
      throw new Error(`T9 failed: ${uploadResult.error}`);
    }

    // Compile results
    const workflowResults = {
      t1_assets: {
        success: assetsResult.success,
        paths_count: assetsResult.data.paths?.length || 0,
        fallback_used: assetsResult.data.fallback_used || false
      },
      t2_prices: {
        success: pricesResult.success,
        price_count: pricesResult.data.prices?.length || 0,
        cheapest_price: pricesResult.data.cheapest || 0,
        currency: pricesResult.data.currency || 'RUB'
      },
      t3_copy: {
        success: copyResult.success,
        language: copyResult.data.language || 'ru',
        subject_length: copyResult.data.subject?.length || 0,
        body_length: copyResult.data.body?.length || 0
      },
      t4_mjml: {
        success: mjmlResult.success,
        html_size_kb: mjmlResult.data.html ? Buffer.byteLength(mjmlResult.data.html, 'utf8') / 1024 : 0,
        compilation_time: mjmlResult.metadata?.compilation_time || 'N/A'
      },
      t5_diff: {
        success: diffResult.success,
        layout_regression: diffResult.data.layout_regression || false,
        change_percentage: diffResult.data.change_percentage || 0,
        significant_changes_count: diffResult.data.significant_changes?.length || 0
      },
      t6_patch: {
        applied: diffResult.data.layout_regression || false,
        success: !diffResult.data.layout_regression || true, // True if no patch needed or patch succeeded
        optimization_score: finalHtml !== mjmlResult.data.html ? 0.8 : 1.0
      },
      t9_upload: {
        success: uploadResult.success,
        html_url: uploadResult.data.html_url,
        total_size_kb: uploadResult.data.total_size_kb || 0,
        storage_type: uploadResult.metadata?.storage_type || 'local'
      }
    };

    const summary = {
      total_tools_tested: 7,
      successful_tools: Object.values(workflowResults).filter((r: any) => r.success !== false).length,
      failed_tools: Object.values(workflowResults).filter((r: any) => r.success === false).length,
      html_generated: !!uploadResult.data.html_url,
      final_html_url: uploadResult.data.html_url,
      workflow_time: Date.now() // Simple timestamp
    };

    return NextResponse.json({
      success: true,
      message: 'Comprehensive workflow test completed successfully!',
      workflow_results: workflowResults,
      summary,
      final_output: {
        html_url: uploadResult.data.html_url,
        mjml_url: uploadResult.data.mjml_url,
        total_size_kb: uploadResult.data.total_size_kb,
        upload_summary: uploadResult.data.upload_summary
      },
      phase_8_2_status: summary.failed_tools === 0 ? 'COMPLETE' : 'PARTIAL'
    });

  } catch (error) {
    console.error('‚ùå Comprehensive workflow test failed:', error);
    
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      message: 'Comprehensive workflow test failed',
      phase_8_2_status: 'FAILED'
    }, { status: 500 });
  }
}

function generateBaselineTemplate(): string {
  return `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Baseline Email Template</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f4f4f4;">
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" border="0" style="background-color: #ffffff;">
          <tr>
            <td style="padding: 20px;">
              <h1 style="color: #333333; font-size: 24px; margin: 0;">Baseline Content</h1>
              <p style="color: #666666; font-size: 16px; line-height: 1.5;">This is baseline template content.</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`;
} 