import { config } from 'dotenv';
import * as path from 'path';

// Load .env.local file
config({ path: path.resolve(process.cwd(), '.env.local') });

// OpenAI Agent SDK imports
import { Agent, tool, withTrace } from '@openai/agents';
import { generateTraceId } from '../validators/agent-handoff-validator';

// Import only what we need to break circular dependency
import { handleToolErrorUnified } from '../core/error-orchestrator';
import { logger } from '../core/logger';

// Define local interfaces to avoid circular import
interface ToolResult {
  success: boolean;
  data?: any;
  error?: string;
  metadata?: Record<string, any>;
}

interface ContentInfo {
  subject: string;
  preheader: string;
  body: string;
  cta: string;
  language: string;
  tone: string;
}

interface PriceInfo {
  origin: string;
  destination: string;
  price: number;
  date: string;
  currency: string;
  metadata?: {
    airline?: string;
    flight_number?: string;
    duration?: number;
    stops?: number;
    estimated?: boolean;
    base_price?: number;
    variation_factor?: number;
  };
}

// Local error handling function
function handleToolError(toolName: string, error: any): ToolResult {
  logger.error(`Tool ${toolName} failed`, { error });
  return handleToolErrorUnified(toolName, error);
}
import { getUsageModel } from '../../shared/utils/model-config';
// import ABTestingService from '../../lib/ab-testing'; // DISABLED - A/B testing framework disabled

// Helper function to clean API keys
function cleanApiKey(apiKey: string | undefined): string | undefined {
  if (!apiKey) return undefined;
  return apiKey.replace(/\s+/g, '').trim();
}

function cleanMarkdownJson(content: string): string {
  // Remove markdown code blocks
  return content
    .replace(/```json\s*/g, '')
    .replace(/```\s*/g, '')
    .replace(/^\s*```/gm, '')
    .replace(/```\s*$/gm, '')
    .trim();
}

interface CopyParams {
  topic: string;
  prices: {
    prices: PriceInfo[];
    currency: string;
    cheapest: number;
  };
}

// CopyGeneratorAgent - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç OpenAI Agent SDK
class CopyGeneratorAgent extends Agent {
  constructor() {
    super({
      name: 'CopyGeneratorAgent',
      description: 'Generates email marketing copy for travel topics',
      model: getUsageModel(),
      tools: [generateCopyTool]
    });
  }
}

// Tool –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–ø–∏—Ä–∞–π—Ç–∏–Ω–≥–∞
const generateCopyTool = tool({
  name: 'generate_marketing_copy',
  description: 'Generate Russian marketing copy for travel emails',
  parameters: {
    type: 'object',
    properties: {
      topic: { type: 'string', description: 'Travel topic or destination' },
      priceContext: { type: 'string', description: 'Price information context' },
      cheapestPrice: { type: 'number', description: 'Cheapest available price' },
      currency: { type: 'string', description: 'Currency for prices' }
    },
    required: ['topic', 'priceContext', 'cheapestPrice', 'currency']
  }
}, async (params) => {
  const prompt = `–¢—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ email-–º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É –¥–ª—è —Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ Kupibilet. 
–°–æ–∑–¥–∞–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –ø–∏—Å—å–º–æ –Ω–∞ —Ç–µ–º—É "${params.topic}" –∏—Å–ø–æ–ª—å–∑—É—è —Ü–µ–Ω—ã –æ—Ç ${params.cheapestPrice} ${params.currency}.

### –ö–æ–Ω—Ç–µ–∫—Å—Ç –±—Ä–µ–Ω–¥–∞:
Kupibilet ‚Äî —ç—Ç–æ —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–± –Ω–∞–π—Ç–∏ –∏ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –∞–≤–∏–∞–±–∏–ª–µ—Ç—ã –æ–Ω–ª–∞–π–Ω. –ú—ã –ø–æ–º–æ–≥–∞–µ–º –ø—É—Ç–µ—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∞–º –Ω–∞—Ö–æ–¥–∏—Ç—å –ª—É—á—à–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏ –≤–æ–ø–ª–æ—â–∞—Ç—å –º–µ—á—Ç—ã –æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è—Ö –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å.

### –î–∞–Ω–Ω—ã–µ –æ —Ü–µ–Ω–∞—Ö:
${params.priceContext}

### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- –ó–∞–≥–æ–ª–æ–≤–æ–∫ –¥–æ 50 —Å–∏–º–≤–æ–ª–æ–≤ —Å —Ü–µ–Ω–æ–π (–∏—Å–ø–æ–ª—å–∑—É–π "–æ—Ç ${params.cheapestPrice} ${params.currency}")
- Preheader –¥–æ 90 —Å–∏–º–≤–æ–ª–æ–≤, –¥–æ–ø–æ–ª–Ω—è—é—â–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
- –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç 200-300 —Å–ª–æ–≤
- –ü—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤
- –¢–æ–Ω: –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π, –º–æ—Ç–∏–≤–∏—Ä—É—é—â–∏–π
- –§–æ–∫—É—Å –Ω–∞ –≤—ã–≥–æ–¥–µ –∏ —ç–º–æ—Ü–∏—è—Ö

### –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã:
- –ñ–∞–∂–¥–∞ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–π –∏ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π
- FOMO (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ)
- –¶–µ–Ω–Ω–æ—Å—Ç—å –∏ —ç–∫–æ–Ω–æ–º–∏—è
- –ú–µ—á—Ç—ã –∏ —Å—Ç—Ä–µ–º–ª–µ–Ω–∏—è
- –£–¥–æ–±—Å—Ç–≤–æ –∏ –ø—Ä–æ—Å—Ç–æ—Ç–∞

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∏—Å—å–º–∞:
1. **–ó–∞–≥–æ–ª–æ–≤–æ–∫**: –ü—Ä–∏–≤–ª–µ–∫–∞—é—â–∏–π –≤–Ω–∏–º–∞–Ω–∏–µ —Å —Ü–µ–Ω–æ–π
2. **Preheader**: –î–æ–ø–æ–ª–Ω—è—é—â–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
3. **–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç**: –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è + –≤—ã–≥–æ–¥–∞ + –ø—Ä–∏–∑—ã–≤
4. **CTA**: –Ø—Å–Ω—ã–π –ø—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é (–ø—Ä–∏–º–µ—Ä—ã: "–ù–∞–π—Ç–∏ –±–∏–ª–µ—Ç—ã", "–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", "–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ü–µ–Ω—ã")

–í–ê–ñ–ù–û: –û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞:
{
  "subject": "...",
  "preheader": "...",
  "body": "...",
  "cta": "..."
}`;

  return prompt;
});

/**
 * T3: Generate Copy Tool
 * Generate email content using dual LLM approach (GPT-4o mini + Claude)
 */
export async function generateCopy(params: CopyParams): Promise<ToolResult> {
  try {
    console.log('üñãÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è —Ç–µ–º—ã:', params.topic);

    // Validate parameters
    if (!params.topic || !params.prices) {
      throw new Error('Topic and prices are required');
    }

    // Check if OpenAI API is available
    const openaiApiKey = process.env.OPENAI_API_KEY;
    if (!openaiApiKey) {
      throw new Error('OpenAI API key not found. OPENAI_API_KEY environment variable is required.');
    }

    try {
      const openai = new OpenAI({
        apiKey: openaiApiKey,
      });

      // Test connectivity with a simple request
      await testOpenAIConnectivity(openai);

      // Generate Russian content only
      const russianContent = await generateRussianContent(openai, params.topic, params.prices);

      const result: ContentInfo = {
        subject: russianContent.subject,
        preheader: russianContent.preheader,
        body: russianContent.body,
        cta: russianContent.cta,
        language: 'ru',
        tone: 'friendly'
      };

      return {
        success: true,
        data: result,
        metadata: {
          topic: params.topic,
          price_info: `–æ—Ç ${params.prices.cheapest} ${params.prices.currency}`,
          timestamp: new Date().toISOString()
        }
      };

    } catch (networkError: any) {
      throw new Error(`Network error: ${networkError.message}`);
    }

  } catch (error: any) {
    return handleToolError('generate_copy', error);
  }
}

async function generateRussianContent(
  openai: OpenAI, 
  topic: string, 
  prices: { prices: PriceInfo[]; currency: string; cheapest: number }
): Promise<Omit<ContentInfo, 'language' | 'tone'>> {
  
  // Defensive checks for prices
  const pricesList = prices?.prices || [];
  const currency = prices?.currency || 'RUB';
  const cheapestPrice = prices?.cheapest || 0;
  
  // Generate price context only if we have valid prices
  let priceContext = '–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –∞–≤–∏–∞–±–∏–ª–µ—Ç—ã';
  if (pricesList.length > 0) {
    priceContext = pricesList.slice(0, 3).map(p => `${p.origin}‚Üí${p.destination}: ${p.price} ${p.currency} (${p.date})`).join('\n');
  }
  
  // Enhanced prompt using content.md guidelines
  const prompt = `–¢—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ email-–º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É –¥–ª—è —Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ Kupibilet. 
–°–æ–∑–¥–∞–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –ø–∏—Å—å–º–æ –Ω–∞ —Ç–µ–º—É "${topic}" –∏—Å–ø–æ–ª—å–∑—É—è —Ü–µ–Ω—ã –æ—Ç ${cheapestPrice} ${currency}.

### –ö–æ–Ω—Ç–µ–∫—Å—Ç –±—Ä–µ–Ω–¥–∞:
Kupibilet ‚Äî —ç—Ç–æ —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–± –Ω–∞–π—Ç–∏ –∏ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –∞–≤–∏–∞–±–∏–ª–µ—Ç—ã –æ–Ω–ª–∞–π–Ω. –ú—ã –ø–æ–º–æ–≥–∞–µ–º –ø—É—Ç–µ—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∞–º –Ω–∞—Ö–æ–¥–∏—Ç—å –ª—É—á—à–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏ –≤–æ–ø–ª–æ—â–∞—Ç—å –º–µ—á—Ç—ã –æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è—Ö –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å.

### –î–∞–Ω–Ω—ã–µ –æ —Ü–µ–Ω–∞—Ö:
${priceContext}

### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- –ó–∞–≥–æ–ª–æ–≤–æ–∫ –¥–æ 50 —Å–∏–º–≤–æ–ª–æ–≤ —Å —Ü–µ–Ω–æ–π (–∏—Å–ø–æ–ª—å–∑—É–π "–æ—Ç ${cheapestPrice} ${currency}")
- Preheader –¥–æ 90 —Å–∏–º–≤–æ–ª–æ–≤, –¥–æ–ø–æ–ª–Ω—è—é—â–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
- –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç 200-300 —Å–ª–æ–≤
- –ü—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤
- –¢–æ–Ω: –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π, –º–æ—Ç–∏–≤–∏—Ä—É—é—â–∏–π
- –§–æ–∫—É—Å –Ω–∞ –≤—ã–≥–æ–¥–µ –∏ —ç–º–æ—Ü–∏—è—Ö

### –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã:
- –ñ–∞–∂–¥–∞ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–π –∏ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π
- FOMO (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ)
- –¶–µ–Ω–Ω–æ—Å—Ç—å –∏ —ç–∫–æ–Ω–æ–º–∏—è
- –ú–µ—á—Ç—ã –∏ —Å—Ç—Ä–µ–º–ª–µ–Ω–∏—è
- –£–¥–æ–±—Å—Ç–≤–æ –∏ –ø—Ä–æ—Å—Ç–æ—Ç–∞

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∏—Å—å–º–∞:
1. **–ó–∞–≥–æ–ª–æ–≤–æ–∫**: –ü—Ä–∏–≤–ª–µ–∫–∞—é—â–∏–π –≤–Ω–∏–º–∞–Ω–∏–µ —Å —Ü–µ–Ω–æ–π
2. **Preheader**: –î–æ–ø–æ–ª–Ω—è—é—â–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
3. **–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç**: –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è + –≤—ã–≥–æ–¥–∞ + –ø—Ä–∏–∑—ã–≤
4. **CTA**: –Ø—Å–Ω—ã–π –ø—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é (–ø—Ä–∏–º–µ—Ä—ã: "–ù–∞–π—Ç–∏ –±–∏–ª–µ—Ç—ã", "–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", "–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ü–µ–Ω—ã")

–í–ê–ñ–ù–û: –û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞:
{
  "subject": "...",
  "preheader": "...",
  "body": "...",
  "cta": "..."
}`;

  try {
    const response = await openai.chat.completions.create({
      model: getUsageModel(),
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
      max_tokens: 1000
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content generated from GPT-4o mini');
    }

    try {
      const cleanedContent = cleanMarkdownJson(content);
      console.log('üîç Cleaned OpenAI content for parsing:', cleanedContent.substring(0, 200) + '...');
      
      const parsed = JSON.parse(cleanedContent);
      console.log('üîç Parsed OpenAI response:', {
        hasSubject: !!parsed.subject,
        hasPreheader: !!parsed.preheader,
        hasBody: !!parsed.body,
        hasCta: !!parsed.cta,
        subjectLength: parsed.subject?.length || 0,
        bodyLength: parsed.body?.length || 0
      });
      
      return {
        subject: parsed.subject,
        preheader: parsed.preheader,
        body: parsed.body,
        cta: parsed.cta
      };
    } catch (parseError: any) {
      console.error('‚ùå Failed to parse OpenAI response. Raw content:', content);
      console.error('‚ùå Cleaned content:', content);
      throw new Error(`Failed to parse OpenAI response: ${parseError.message}`);
    }
    
  } catch (apiError: any) {
    throw new Error(`OpenAI API failed: ${apiError.message}`);
  }
}

async function testOpenAIConnectivity(openai: OpenAI): Promise<void> {
  try {
    // Simple test to check if OpenAI API is reachable
    await openai.models.list();
  } catch (error: any) {
    if (error.message.includes('ENOTFOUND') || error.message.includes('fetch failed')) {
      throw new Error('Network connectivity issue - OpenAI API unreachable');
    }
    throw error;
  }
}



 